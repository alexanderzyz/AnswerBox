# 数据结构计蒜客实验

由于计蒜客系统已经关闭，我没能及时把在计蒜客上写的代码同步到自己电脑上，因此只能在此放一些自己的思路和自己遇到的问题，供大家参考

## 公司管理系统

第一个实验相对简单，按部就班完成他要求的任务即可

这里重点说一下我遇到的问题：

我个人认为这道题最重要最难完成的是swap()函数，即实现交换

因为会涉及到以下的问题

1. 交换元素存在头结点
2. 交换元素存在尾结点
3. 交换元素相邻（**最关键最容易忽略**）

这三种情况，两个元素排列组合，情况实在太多，因此我解决的方法是：

在交换之前在创两个节点，**一个节点a插入到头结点之前，一个节点b插入尾结点之后**，这样在交换时就不用考虑头尾节点的问题，头结点永远是a->next,尾结点永远是b->prev，当然也要注意要**重写一下节点的构造函数**，防止我们创建a,b节点时类的静态变量自加导致节点数目出现问题。

这时只需要单独处理交换元素相邻这一种情况了，可以自己在纸上画图找规律，相对正常情况实际上是少了两次操作，只需要6次操作，正常需要8次



## 文本编辑程序

这个实验也没遇到太大的问题，个人感觉注意：

重载运算符的时候要判断`if(&other != this)` ，之后先把自身的内存回收，再进行赋值

`resume()`和`undo()` 操作的时候注意如果栈为NULL要新建栈

最后不用循环实现栈和队列的比较（其实用循环也能过）：

大概思路就是利用递归，先把栈中的元素全pop()后入队，再把原队列中的元素全压栈（相当于交换栈和队列但是改变了顺序），此时获得的新栈和新队列逐个pop()，全部相等则栈和队列相等。最先判断大小是否相等，不相等直接返回false,然后栈pop（）元素个数此，设立两个判断点,judge1用来判断stack是否出栈空，空改变judge1，原队列全部入栈后改变judge2,根据两个judge的状态分别进行判断操作。

还要注意,**judge1和judge2设置为全局变量时，每次第一次调用比较函数时第一件事就是先把judge1和judge2初始化**，否则一个程序多次调用比较函数时会导致judge1和judge2是非初始化的，程序会出错

## 文学作品分析

hash表的构建是关键

我的构造方法也是常规的：把字母看做26进制数，然后将字母转为数字，取余小于哈希表容量的最大质数（此质数要提前自己算出来直接取余此数，不要在程序中计算，否则可能会超时）

其余的就是常规的线性探测法，超过哈希表长度后扩大为原来的两倍再把原来的复制过去（直接第一次申请较大的内存就可以不考虑这部分），**我记得好像Insert()函数在说明中说返回什么数都可以，便于自己调试，但是那里不返回1（还是0我忘了）还是会错！记得一定要返回他第一次说的那个值，要不然会调试很长时间**

word_check()函数的算法过于简单，居然只是遇到非字母的就把这个单词拆为两个单词，如num2str就拆分为num和str而不是认为这个字符串不是单词，这让我写的按照标点符号递归的算法根本过不了，这部分还是借鉴了别人的代码才完成的。就按照最简单的方法写就可以了，遇到`isalpha()==false`的字符就把这个前面和这个后面隔断，直到找到下一个`isalpha()==true`的字符再开始记录这个单词

## 滤镜功能

这道题我认为应该是实验中最难的一道。理解了题目，分布调试观察每步写的对不对，从理解的角度并没有那么难，但是代码量确实多，细节也很多，这导致了这道题相对较难

本质上就是建立一个四叉树，我使用的是递归建立，主要在传图片的宽和高时不能直接传width/2，因为如果width是奇数的话子树的width就错了,应该**一个儿子为width/2，另一个是width-width/2**，

剪枝的方法其实就是记录叶子节点被剪枝的最大值就可以了，因为每次剪枝必然会剪枝到叶子节点，叶子结点一定是经历过最多剪枝的

平均rgb的计算也非常重要，**剪枝之后要记得重新恢复原叶子节点的平均rgb为原来的值**

最后我个人最痛苦的是调试内存问题，内存一直有一个案例无法通过，我认为内存有以下两点：

1. 构造函数左值右值，运算符重载左值右值搞清楚，左值一定要重新建立内存，右值可以直接把参数中的量直接赋值过来，不用新申请内存
2. 不要动（在自己的代码里别delete ）root根节点，虽然我也不知道为什么，但是每次我delete root再重新申请root内存就会内存错误，只能在load_png里再指定root的属性了，不要delete后再利用构造函数重新申请root更改他的属性

## 排位系统

相比于滤镜简单多了

搞清楚小根堆和堆排序的原理做这题问题就不算太大，唯一有些差别的可能就是构建堆的方式，由于数据实际上是一个一个插进去而不是一个堆直接构建好的，所以实际上只需要堆未满时用heapify_up()，堆满了判断条件后用heapify_down()把根节点向下堆化就可以了。

## 高速路网设计

题目很好理解，两点间的最短路径算法一个dijkstra就可以了，主要解决的就是根据图片构建图的关系

我的想法是:

找寻每个六边形一个独一无二的特征来记录他的位置和颜色

我选取的位置是：对于一个六边形，**取(0,6)这个位置**，即六边形左边的中点

然后我x方向逐次遍历，y方向每次加8遍历，判断(1,6)的位置如果不是白色，则证明此处有一个六边形，如果此处有一个六边形，则我遍历此六边形之前的点，如果有满足和此六边形关系为：**左方，左上，右上**（可以当y坐标距离超过8时搜索结束或者找到了三个结束以节约时间），就可以在图中标出这几个点临接，在根据颜色算出距离，根据有向图的dijkstra算法算出第一个六边形到最后一个的距离就可以了

